/**
 * Simulation from startTime to the present under AnaDSGBM2, returns observed Tree (without extinctions)
 *
 * To run the simulation use:
 * npm run wppl tree_simulations/treesim-anadsGBM1.wppl NSIMS INFERENCE_DIR AGE RHO
 *
 */

// Setting parameters/priors
var dirname = argv["_"][1] // dirname is now the directory where the sims are stored // samples will be drawn from it
var age = argv["_"][2]     // simulation age
var rho = argv["_"][3]     // simulation rho                      

// Number of Taxa Globally (side-effect)
globalStore.n = 0;

/* Helper function to check for errors in the tree 
 * @param tree is a [String], i.e. tree
 * @return Boolean
 */
var checkError = function (tree) {
  var stringTree = tree.join("")
  if (stringTree.includes("ERROR")) {
    return true
  } else
    return false
}

/* Helper function to read in data */
var getHyperParamsFromDir = function (dirname) {
  var sample = phyjs.sample(dirname)
  return {
    startTime: age,
    lambda0: sample.lambda,
    mu: sample.mu,
    logAlpha: sample.log_Î±_gbm,
    sigma: sample.sigma2_gbm,
    rho: rho,
    stepsize: 0.05,
    max_R: 5000,
    MAX_LAMBDA: 1e12,
    MAX_NODES: 1e6,
    MAX_DIV: 1e12
  }
}

///////////////////////////////library code//////////////////////////////////////////////////////////////
/**
 * Wrapper to the simulation function
 * Checks for errors and assembles the tree
 * Re-starts simulation if either left or right tree fails
 */
var anads2TreeSimulate = function (dirname) {
  var obj = getHyperParamsFromDir(dirname)
  var startTime = obj.startTime
  var lambda0 = obj.lambda0
  var mu = obj.mu
  var logAlpha = obj.logAlpha
  var sigma = obj.sigma
  var rho = obj.rho
  var stepsize = obj.stepsize
  var max_R = obj.max_R
  var MAX_LAMBDA = obj.MAX_LAMBDA
  var MAX_NODES = obj.MAX_NODES
  var MAX_DIV = obj.MAX_DIV

  var TreeLeft = anads2TreeSim(startTime, lambda0, stepsize, logAlpha, sigma, mu, rho, max_R, MAX_LAMBDA, MAX_NODES, MAX_DIV);
  if (TreeLeft == false) {
    console.log("Error: No survivors in this subtree")
    globalStore.n = 0 // we need to reset counter before we start over
    return anads2TreeSimulate(dirname)
  }
  else {
    var stringTreeLeft = TreeLeft.join("")
    if ((stringTreeLeft.includes("ERROR_MAX")) || (stringTreeLeft.includes("ERROR_ZERO"))) {
      console.log("Error: Guards hit")
      globalStore.n = 0 // we need to reset counter before we start over
      return anads2TreeSimulate(dirname)
    }
    else { //So first tree is ok
      var TreeRight = anads2TreeSim(startTime, lambda0, stepsize, logAlpha, sigma, mu, rho, max_R, MAX_LAMBDA, MAX_NODES, MAX_DIV);
      if (TreeRight == false) {
        console.log("Error: No survivors in this subtree")
        globalStore.n = 0 // we need to reset counter before we start over
        return anads2TreeSimulate(dirname)
      }
      else {
        var stringTreeRight = TreeRight.join("")
        if ((stringTreeRight.includes("ERROR_MAX")) || (stringTreeRight.includes("ERROR_ZERO"))) {
          console.log("Error: Guards hit")
          globalStore.n = 0 // we need to reset counter before we start over
          return anads2TreeSimulate(dirname)
        }
        else { //So both the first and second tree is ok. Join trees and output:
          var stringTree = [TreeLeft.join('') + ',' + TreeRight.join('')];
          var Tree = "(" + stringTree + ")" + ';';
          //fs.write(filename, Tree);
          return Tree
        }
      }
    }
  }
}

/**
 * Simulation function
 */
var anads2TreeSim = function (startTime, lambda, stepsize, logAlpha, sigma, epsilon, rho, max_R, MAX_LAMBDA, MAX_NODES, MAX_DIV) {
  var mu = epsilon * lambda

  // extreme values patch
  if (max_R == 0) {
    return ["ERROR_MAX_RECURSION:", startTime]
  }
  if (lambda > MAX_LAMBDA) {
    return ["ERROR_MAX_LAMBDA:", startTime]
  }
  if (lambda - mu > MAX_DIV) {
    return ["ERROR_MAX_DIV:", startTime]
  }
  if (lambda == 0.0 || mu == 0.0) {
    return ["ERROR_ZERO:", startTime]
  }
  if (globalStore.n > MAX_NODES) {
    return ["ERROR_MAX_TAXA:", startTime]
  } // end extreme values patch

  var timeToSpeciation = exponential({
    a: lambda
  })
  var timeToExtinction = exponential({
    a: mu
  })
  var timeToAnagenesis = stepsize

  if (timeToAnagenesis < timeToSpeciation && timeToAnagenesis < timeToExtinction) { // Anagenetic event
    var currentTime = startTime - timeToAnagenesis;
    if (currentTime < 0) { // Handle reaching present
      globalStore.n = globalStore.n + 1;
      if (flip(rho)) {
        var Label = "Taxon_" + globalStore.n + ':';
        var NewickTree = [Label, startTime]; // Make start on tree
        return NewickTree;
      } else {
        return false; //Survived to present, but not sampled. Remove branch.
      }
    }
    var internalBranch = timeToAnagenesis;
    var multip = Math.exp(gaussian({
      mu: logAlpha * stepsize,
      sigma: sigma * Math.sqrt(stepsize)
    })) // Draw and calc new multiplier
    var lambdaNew = lambda * multip;
    var Tree = anads2TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, epsilon, rho, max_R - 1, MAX_LAMBDA, MAX_NODES, MAX_DIV); // Continue along branch
    if (Tree == false) { // Extinct/not sampled
      return false;
    } else {
      var newBranch = Tree[1] + internalBranch; // Add the two "final" branches
      var NewickTree = [Tree[0], newBranch]; // build correct final tree
      return NewickTree;
    }
  } else { // Speciation/cladogenetic event
    var timeToEvent = Math.min(timeToSpeciation, timeToExtinction);
    var currentTime = startTime - timeToEvent;
    var internalBranch = timeToEvent; // Calculate length of internal branch leading up to event
    if (currentTime < 0) { // We have reached the present
      globalStore.n = globalStore.n + 1;
      if (flip(rho)) {
        var Label = "Taxon_" + globalStore.n + ':';
        var NewickTree = [Label, startTime]; // Make start on tree
        return NewickTree;
      } else {
        return false; //Survived to present, but not sampled. Remove branch.
      }
    }
    if (timeToExtinction == timeToEvent) { // Extinction
      return false; // Remove branch
    } else { // Speciation; first draw values for daughter lineages and then recurse	          
      var delta = timeToSpeciation; // Anagenetic "update" event at branching point
      var multip = Math.exp(gaussian({
        mu: logAlpha * delta,
        sigma: sigma * Math.sqrt(delta)
      })) // Draw and calc new multiplier
      var lambdaNew = lambda * multip; // Calculate new lambda

      // Speciation/cladogenetic event
      // Get back two Newick strings, partial trees
      var leftTree = anads2TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, epsilon, rho, max_R - 1, MAX_LAMBDA, MAX_NODES, MAX_DIV);
      // Check if the left Tree contains an error condition
      if (leftTree && checkError(leftTree)) {
        return leftTree; // return only left tree immediately
      }

      var rightTree = anads2TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, epsilon, rho, max_R - 1, MAX_LAMBDA, MAX_NODES, MAX_DIV);
      if (rightTree && checkError(rightTree)) {
        return rightTree
      } // also check right tree for error

      if (leftTree == false && rightTree == false) { // Both sides are extinct/not sampled
        return false;
      }
      if (rightTree == false) {
        var newBranch = leftTree[1] + internalBranch; // Add the two branches
        var NewickTree = [leftTree[0], newBranch]; // build correct tree without the extinct side
        return NewickTree;
      }
      if (leftTree == false) {
        var newBranch = rightTree[1] + internalBranch; // Add the two branches
        var NewickTree = [rightTree[0], newBranch]; // build correct tree without the extinct side
        return NewickTree;
      } else {
        var NewickTree = ['(' + leftTree.join('') + ',' + rightTree.join('') + ')' + ':', internalBranch]; // Merge trees
        return NewickTree;
      }
    }
  }
}
////////////////////////////////end library code////////////////////////////////////////////////////////////////////

anads2TreeSimulate(dirname)
