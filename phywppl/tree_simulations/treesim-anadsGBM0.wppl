/**
 * Simulation from startTime to the present under AnaDSGBM0, returns observed Tree (without extinctions)
 *
 * To run the simulation use:
 * npm run wppl tree_simulations/treesim-anadsGBM0.wppl NSIMS INFERENCE_DIR AGE RHO
 *
 */

// Setting parameters/priors
var dirname = argv["_"][1] // dirname is now the directory where the sims are stored and samples will be drawn from it
var age = argv["_"][2]     // simulation age
var rho = argv["_"][3]     // simulation rho

// Number of Taxa Globally (side-effect)
globalStore.n = 0;

/* Helper function to check for errors in the tree 
 * @param tree is a [String], i.e. tree
 * @return Boolean
 */
var checkError = function (tree) {
  var stringTree = tree.join("")
  if (stringTree.includes("ERROR")) {
    return true
  } else
    return false
}

/* Helper function to read in data */
var getHyperParamsFromDir = function (dirname) {
  var sample = phyjs.sample(dirname)
  return {
    startTime: age,
    lambda0: sample.lambda,
    mu: sample.mu,
    logAlpha: sample.log_Î±_gbm, 
    sigma: sample.sigma2_gbm,
    rho: rho,
    stepsize: 0.05,
    max_R: 5000,
    MAX_LAMBDA: 1e12,
    MAX_NODES: 1e6,
    MAX_DIV: 1e12
  }
}

///////////////////////////////library code//////////////////////////////////////////////////////////////
/**
 * Wrapper to the simulation function
 * Checks for errors and assembles the tree
 * Re-starts simulation if either left or right tree fails
 */
var anads0TreeSimulate = function (dirname) {
  var obj = getHyperParamsFromDir(dirname)
  var startTime = obj.startTime
  var lambda0 = obj.lambda0
  var logAlpha = obj.logAlpha
  var sigma = obj.sigma
  var rho = obj.rho
  var stepsize = obj.stepsize
  var max_R = obj.max_R
  var MAX_LAMBDA = obj.MAX_LAMBDA
  var MAX_NODES = obj.MAX_NODES

  /* MAX_DIV and mu are not needed for this model */

  var TreeLeft = anads0TreeSim(startTime, lambda0, stepsize, logAlpha, sigma, rho, max_R, MAX_LAMBDA, MAX_NODES);
  if (TreeLeft == false) {
    console.log("Error: No survivors in this subtree")
    globalStore.n = 0 // we need to reset counter before we start over
    return anads0TreeSimulate(dirname)
  }
  else {
    var stringTreeLeft = TreeLeft.join("")
    if ((stringTreeLeft.includes("ERROR_MAX")) || (stringTreeLeft.includes("ERROR_ZERO"))) {
      console.log("Error: Guards hit")
      globalStore.n = 0
      return anads0TreeSimulate(dirname)
    }
    else { //So first tree is ok
      var TreeRight = anads0TreeSim(startTime, lambda0, stepsize, logAlpha, sigma, rho, max_R, MAX_LAMBDA, MAX_NODES);
      if (TreeRight == false) {
        console.log("Error: No survivors in this subtree")
        globalStore.n = 0
        return anads0TreeSimulate(dirname)
      }
      else {
        var stringTreeRight = TreeRight.join("")
        if ((stringTreeRight.includes("ERROR_MAX")) || (stringTreeRight.includes("ERROR_ZERO"))) {
          console.log("Error: Guards hit")
          globalStore.n = 0
          return anads0TreeSimulate(dirname)
        }
        else { //So both the first and second tree is ok. Join trees and output:
          var stringTree = [TreeLeft.join('') + ',' + TreeRight.join('')];
          var Tree = "(" + stringTree + ")" + ';';
          //fs.write(filename, Tree);
          return Tree
        }
      }
    }
  }
}

/**
 * Simulation function
 */
var anads0TreeSim = function (startTime, lambda, stepsize, logAlpha, sigma, rho, max_R, MAX_LAMBDA, MAX_NODES) {
  // extreme values patch
  if (max_R == 0) {
    console.log("MAX_REC")
    return ["ERROR_MAX_RECURSION:", startTime]
  }
  if (lambda > MAX_LAMBDA) {
    console.log("MAX_LAMBDA")
    return ["ERROR_MAX_LAMBDA:", startTime]
  }
  if (lambda == 0.0) {
    console.log("ZERO")
    return ["ERROR_ZERO:", startTime]
  }
  // causes potential error
  if (globalStore.n > MAX_NODES) {
    console.log("MAX_TAXA")
    return ["ERROR_MAX_TAXA:", startTime]
  }
  //end extreme values patch

  var timeToSpeciation = exponential({
    a: lambda
  })
  var timeToAnagenesis = stepsize

  //Anagenetic event
  if (timeToAnagenesis < timeToSpeciation) {
    var currentTime = startTime - timeToAnagenesis;

    if (currentTime < 0) {
      globalStore.n = globalStore.n + 1; // new taxon
      if (flip(rho)) {
        var Label = "Taxon_" + globalStore.n + ':';
        var NewickTree = [Label, startTime]; // Make start on tree
        return NewickTree;
      } else {
        return false; //Survived to present, but not sampled. Remove branch.
      }
    }

    var internalBranch = timeToAnagenesis;
    var multip = Math.exp(gaussian({
      mu: logAlpha * stepsize,
      sigma: sigma * Math.sqrt(stepsize)
    })) // Draw and calc new multiplier
    var lambdaNew = lambda * multip; // Calculate new lambda
    var Tree = anads0TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, rho, max_R - 1, MAX_LAMBDA, MAX_NODES); // Continue along branch
    if (Tree == false) { // Extinct/not sampled
      return false;
    } else {
      var newBranch = Tree[1] + internalBranch; // Add the two "final" branches
      var NewickTree = [Tree[0], newBranch]; // build correct final tree
      return NewickTree;
    }
  } else {
    //Speciation/cladogenetic event
    var currentTime = startTime - timeToSpeciation;
    var internalBranch = timeToSpeciation; // Length of internal branch leading up to event

    if (currentTime < 0) {
      globalStore.n = globalStore.n + 1;
      if (flip(rho)) {
        var Label = "Taxon_" + globalStore.n + ':'; //Survived to present, sampled. Start tree: Set random label to leaf node
        var NewickTree = [Label, startTime]; // Make start on tree
        return NewickTree;
      } else {
        return false; //Survived to present, but not sampled. Remove branch.
      }
    } else { // Not reached present: Speciation
      //Anagenetic "update" event at branching point
      var delta = timeToSpeciation;
      var multip = Math.exp(gaussian({
        mu: logAlpha * delta,
        sigma: sigma * Math.sqrt(delta)
      })) // Draw and calc new multiplier
      var lambdaNew = lambda * multip; // Calculate new lambda

      //Speciation/cladogenetic event
      var leftTree = anads0TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, rho, max_R - 1, MAX_LAMBDA, MAX_NODES); // Get back two Newick strings, partial trees

      // Check if the left Tree contains an error condition
      if (leftTree && checkError(leftTree)) {
        return leftTree; // return only left tree immediately
      }

      var rightTree = anads0TreeSim(currentTime, lambdaNew, stepsize, logAlpha, sigma, rho, max_R - 1, MAX_LAMBDA, MAX_NODES); // Get back two Newick strings, partial trees
      if (rightTree && checkError(rightTree)) {
        return rightTree
      } // also check right tree for error

      if (leftTree == false && rightTree == false) { // Both sides are extinct/not sampled
        return false;
      }
      if (rightTree == false) {
        var newBranch = leftTree[1] + internalBranch; // Add the two branches
        var NewickTree = [leftTree[0], newBranch]; // build correct tree without the extinct side
        return NewickTree;
      }
      if (leftTree == false) {
        var newBranch = rightTree[1] + internalBranch; // Add the two branches
        var NewickTree = [rightTree[0], newBranch]; // build correct tree without the extinct side
        return NewickTree;
      } else {
        var NewickTree = ['(' + leftTree.join('') + ',' + rightTree.join('') + ')' + ':', internalBranch]; // Merge trees
        return NewickTree;
      }
    }
  }
}

////////////////////////////////end library code////////////////////////////////////////////////////////////////////

anads0TreeSimulate(dirname)
